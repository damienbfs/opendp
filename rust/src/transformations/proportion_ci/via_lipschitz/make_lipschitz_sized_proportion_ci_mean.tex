\documentclass[11pt,a4paper]{article}
\usepackage{amsmath,amsthm,amsfonts,amssymb,amscd}
\usepackage{enumerate} 
\usepackage{physics}
\usepackage{enumerate}
\usepackage{fancyhdr}
\usepackage{hyperref}
\hypersetup{colorlinks,
    linkcolor=blue,
    citecolor=blue,      
    urlcolor=blue,
}
\usepackage{graphicx}


\oddsidemargin0.1cm 
\evensidemargin0.8cm
\textheight22.7cm 
\textwidth15cm \topmargin-0.5cm

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}

\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\newcommand{\silvia}[1]{{ {\color{blue}{(silvia)~#1}}}}
\newcommand{\grace}[1]{{ {\color{purple}{(grace)~#1}}}}
\newtheorem{definition}{Definition}
\newcommand{\MultiSet}{\mathrm{MultiSet}}
\newcommand{\len}{\mathrm{len}}
\newcommand{\din}{\texttt{d\_in}}
\newcommand{\dout}{\texttt{d\_out}}
\newcommand{\T}{\texttt{T} }
\newcommand{\F}{\texttt{F} }
\newcommand{\Relation}{\texttt{Relation}}
\newcommand{\X}{\mathcal{X}}
\newcommand{\Y}{\mathcal{Y}}
\newcommand{\True}{\texttt{True}}
\newcommand{\False}{\texttt{False}}
\newcommand{\clamp}{\texttt{clamp}}
\newcommand{\function}{\texttt{function}}
\newcommand{\float}{\texttt{float }}
\newcommand{\questionc}[1]{\textcolor{red}{\texttt{Question:} #1}}

\title{Privacy Proofs for OpenDP: Lipschitz Sized Mean for Proportion CI (for Partitioned Data)}
\author{}
\date{Summer 2022}
\begin{document}

\maketitle
\tableofcontents


\section{Algorithm Implementation}





\subsection{Code in Rust}



The current OpenDP library contains the \texttt{make\_lipschitz\_sized\_proportion\_ci\_mean} function estimating the overall sample proportion for partitioned data. This is defined 
in lines 34-182 of the file \texttt{mod.rs}
in the Git repository \url{https://github.com/opendp/opendp/blob/e9a8ce533a900a6561c0ea3be6bea8c985311374/rust/src/trans/proportion_ci/mod.rs#L134-L182}.



\subsection{Pseudo Code in Python} \label{sec:pseudocode}
% https://github.com/opendp/prelim/blob/Shuronglin-StratifiedSampling-CI/python/alg_NoisePop_PubSize.ipynb

\subsection*{Preconditions}
To ensure the correctness of the output, we require the following preconditions:

\begin{itemize}
    \item \texttt{User-specified types:}
    \begin{itemize}
        \item Variable \texttt{sample\_sizes} must be of type \texttt{Vec<usize>}. 
        \item Variable \texttt{strat\_sizes} must be of type \texttt{Vec<usize>}. 
        \item \texttt{TA}: must be of type  \texttt{float}.
    \end{itemize}
    
\end{itemize}


\subsection*{Postconditions}
\begin{itemize}
    \item A \texttt{transformation} is returned (i.e., if a \texttt{transformation} cannot be returned successfully, then an error should be returned).
\end{itemize}

\subsection*{Pseudo Code}
\begin{lstlisting}[language=Python, escapechar=|]
def (sample_sizes: Vec<TA>, strat_sizes: Vec<TA>) -> TA:
    '''
    :param strat_sizes: the population size of each stratum
    :param sample_sizes: sample sizes in each stratum 
    '''
    input_domain = ProductDomain<AllDomain<TA>>
    output_domain = AllDomain<TA>
    strat_weights = strat_sizes / sum(strat_sizes)
    def function(sample_sums: Vec<TA>) -> TA:
        strat_means = sample_sums / sample_sizes
        return sum(strat_weights * strat_means)
    input_metric = ProductMetric<AbsoluteDistance<TA>>
    output_metric = AbsoluteDistance<TA>
    def stability_map(d_in: AbsoluteDistance<TA>) -> TA:
        sens = max(strat_weights / sample_sizes)
        return d_in * sens
        
    return Transformation(input_domain, output_domain, function, input_metric, output_metric, stability_map)         
\end{lstlisting}


\section{Proof}

\begin{theorem} For every setting of the input parameters \texttt{sample\_sizes} and \texttt{strat\_sizes} to  \texttt{make\_lipschitz\_sized\_proportion\_ci\_mean} such that the given preconditions hold,\\ \texttt{make\_lipschitz\_sized\_proportion\_ci\_mean} raises an exception (at compile time or runtime) or returns a valid \texttt{transformation} with the following properties:
    \begin{enumerate}
        \item \textbf{\textup{(Appropriate output domain).}} For every vector $v$ in the input domain, $\function(v)$ is in the output domain.
        
        \item \textbf{\textup{(Domain-metric compatibility).}} The domain \texttt{input\_domain} matches one of the possible domains listed in the definition of \texttt{input\_metric}, and likewise \texttt{output\_domain} matches one of the possible domains listed in the definition of \texttt{output\_metric}.
        
        \item \textbf{\textup{(Stability guarantee).}} For every pair of elements $v$, $w$ in \texttt{input\_domain} and for any $\din$,  where $\din$ has the associated type for \texttt{input\_metric}, if $v$, $w$ are $\din$-close under \texttt{input\_metric}, then \texttt{function($v$)}, \texttt{function($w$)} are \texttt{stability\_map($\din$)}-close under \texttt{output\_metric}.
    \end{enumerate}
\end{theorem}

\begin{proof}
\hfill
\begin{enumerate}


    \item \textbf{(Appropriate output domain).} 
    From line 6, we know \texttt{strat\_weights} is of type \texttt{Vec<TA>}. On line 12, \texttt{strat\_means} will also be of type \texttt{Vec<TA>} since both \texttt{strat\_sizes} and \texttt{sample\_sizes} are of type \texttt{Vec<TA>}.
    The function returns a sum of a vector of type \texttt{Vec<TA>}, then the sum will be of type \texttt{TA}. That is, the output is in the output domain \texttt{AllDomain<TA>}.
    
    
    
    \smallskip
    \item \textbf{(Domain-metric compatibility).}
    The input domain of  \\
    \texttt{make\_lipschitz\_sized\_proportion\_ci\_mean} is \texttt{ProductDomain} of \texttt{AllDomain<TA>} and the input metric is \texttt{ProductMetric} of \texttt{AbsoluteDistance<TA>}.
    Each component of the input is in \texttt{AllDomain<TA>}.
    Since \texttt{AllDomain<TA>} matches one of the possible domains listed in the definition of \texttt{AbsoluteDistance}, 
    the input domain is compatible with the input metric.
    
    Also, it follows directly that the output domain (\texttt{AllDomain<TA>}) is compatible with the output metric (\texttt{AbsoluteDistance<TA>}). 
    
   
    
    \smallskip
    \item \textbf{(Stability guarantee.)} Let \texttt{Abs} stand for \texttt{AbsoluteDistance}.
    If $v, w$ are \texttt{d\_in}-close, then by the definition \ref{def:prodm},
    \begin{equation*}
        d_\texttt{PM,Abs}(v, w) = \sum_{i}d_\texttt{Abs}(v_i, w_i) \leq \texttt{d\_in},    
    \end{equation*}
    Let $f$ denote the function in \texttt{make\_lipschitz\_sized\_proportion\_ci\_mean}. For ease of notation, let $c_i$ and $n_i$ denote the $i$th element of \texttt{stra\_weights} and \texttt{sample\_sizes}, respectively. Then 
    \begin{equation*}
        \begin{aligned}
            d_\texttt{Abs}(f(v), f(w))  & = \left|\sum_{i} c_i \cdot \frac{v_i}{n_i} - \sum_{i} c_i \cdot \frac{w_i}{n_i} \right| \\
            & = \sum_{i} \frac{c_i}{n_i} \left| v_i - w_i \right| \\
            & = \sum_{i} \frac{c_i}{n_i} \cdot d_\texttt{Abs}(v_i, w_i) \\
            & \leq \max_i \frac{c_i}{n_i} \cdot
            \sum_{i}  d_\texttt{Abs}(v_i, w_i)\\
            & \leq \max_i \frac{c_i}{n_i} \cdot
            \texttt{d\_in}.
        \end{aligned}
    \end{equation*}
    That is, $f(v)$ and $f(w)$ are \texttt{stability\_map(d\_in)}-close.  
    
   
\end{enumerate}
\end{proof}

    \begin{definition}[Distance under \texttt{ProductMetric}]\label{def:prodm}
     Let $d_{\texttt{PM,M}}$ denote the distance under \texttt{ProductMetric(M)} where \texttt{M} is a valid metric. Then $d_{\texttt{PM,M}}$ is defined as the sum of distance under each \texttt{M}. Specifically, for any $v$, $w$ in the input domain and $v_i$, $w_i$ denote their $i$th entry, respectively, 
     
     (i) for input metric \texttt{MI}, 
     \begin{equation*}
    \begin{aligned}
        d_{\texttt{PM,MI}}(v,w) &
        = \sum_{i} d_{\texttt{MI}}(v_i, w_i).
    \end{aligned}
    \end{equation*}
 
     (ii) for output metric \texttt{MO},
    \begin{equation*}
    \begin{aligned} 
        d_{\texttt{PM,MO}}(g(v), g(w)) &
        = \sum_{i} d_{\texttt{MO}}(f_i(v_i), f_i(w_i)),
    \end{aligned}
    \end{equation*} 
    where $g$ and $f_i$ denote the \texttt{function} in their corresponding $\texttt{Transformation}$.
    \end{definition}
    
\end{document}